package com.nanaimostudio.utils{	import com.nanaimostudio.utils.debug.Debug;	import flash.events.Event;		import flash.display.Sprite;		import flash.display.MovieClip;		/**			*	USAGE:	*	var notifier = new PlayHeadNotifier(	*		{	*			target: gameOverWindow,	*			_notifyType: PlayHeadNotifier.STOP,	*			_callback: Delegate.create( this, finishedOpenGameOver )	*		} );		*		*	PlayHeadNotifier.notifyStop( mcWindow, windowOpened );	**/			public class PlayHeadNotifier extends Sprite	{		private var _id:String;		private static var globalID:int = 0;				private var _targetMC:MovieClip;		/* movieclip whose playhead is to be observed */		//private var timeline:MovieClip;		/* the timeline to attach this notifier to */			private var _notifyType:Number;		/* what type of events should trigger a notification */		private var _callback:Function;		/* function to call for all notification */		// add this back in if you need it?		//private var callbackParam:Object;		/* params to pass when _callback is invoked */			private var _prevFrame:Number;			public var isRunning:Boolean = false;			//static var initBeacon = mx.transitions.OnEnterFrameBeacon.init();		//static var initBroadcaster = BroadcasterMX.initialize (PlayHeadNotifier.prototype, true);			//private var notifyExtraInfo:Object;			public static const EOF		:Number	= 1;	/* notifies at the end of the mc */		public static const FRAME	:Number	= 2;	/* notifies every frame */		public static const STOP	:Number	= 4;	/* notifies when it reaches a stop frame */		public static const LOOP	:Number	= 8;	/* notifies when it reaches a stop frame */				//TODO: add a notifyWaitStop that takes an interval like ms value to call the reference		// function after a pause.		public static function notifyStop(target:MovieClip, callback:Function):PlayHeadNotifier		{			var notifier:PlayHeadNotifier =				new PlayHeadNotifier( {					target: target,					notifyType: PlayHeadNotifier.STOP,					callback: callback				} );			return notifier;		}				public static function notifyEnd(target:MovieClip, callback:Function):PlayHeadNotifier		{			var notifier:PlayHeadNotifier =				new PlayHeadNotifier( {					target: target,					notifyType: PlayHeadNotifier.EOF,					callback: callback				} );			return notifier;		}				public function PlayHeadNotifier(notifyParams:Object):void		{			if (notifyParams != null )			{				init(notifyParams);			}		}				public override function toString():String		{			return "[PlayHeadNotifier " + _id + "]";		}			public function reset():void		{			if (isRunning) stop();						_targetMC = null;			_callback = null;		}				private function init(notifyParams:Object):void		{				_id = "@" + (globalID++);						//timeline 	= notifyParams.timeline;			_targetMC 	= notifyParams.target;				////trace("CORE: "+"init PlayHeadNotifier on " + targetMC );				_notifyType = notifyParams.notifyType || EOF;			//notifyExtraInfo = notifyParams.notifyExtraInfo;				_callback = notifyParams.callback;			//callbackParam = notifyParams.callbackParam;				_prevFrame = 1;				if ( _notifyType && _callback != null )			{				start();			}		}				public function start():void		{			addEventListener( Event.ENTER_FRAME, checkFrame );			isRunning = true;			_prevFrame--;		}			// suspend the notifier without removing reference to the functionality.		public function stop():void		{			////trace("stopping notifier");			removeEventListener( Event.ENTER_FRAME, checkFrame );			isRunning = false;		}			// suspend the notifier without removing reference to the functionality.		public function destroy():void		{			//trace("destroying notifier");			stop();			reset();		}			// restart the notifier after it is stop()'ed		public function restart():void		{			addEventListener( Event.ENTER_FRAME, checkFrame );			isRunning = true;		}			private function checkFrame( e:Event ):void		{			//Debug.log(toString() + " Notify type: " + _notifyType + " PlayHeadNotifier.checkFrame " + _targetMC.currentFrame + " of " +  _targetMC.totalFrames);			if ( isRunning )			{				// Not really using this but keeping it for now.				if ( _notifyType & FRAME )				{					////trace("CORE: "+"[PlayHeadNotifier - frame] frame #: " + targetMC.currentFrame + " of " + targetMC.totalframes);					//if ( notifyExtraInfo != null )					//{						//if ( notifyExtraInfo.notifyOnFrameNum > 0 )						//{							//if ( targetMC.currentFrame >= notifyExtraInfo.notifyOnFrameNum )							//{							if (_callback != null) _callback();							//}						//}					//}				}						if (_notifyType & STOP)				{					//Debug.log("[PlayHeadNotifier - stop] frame #: " + targetMC.currentFrame + " of " + targetMC.totalFrames);					if (_targetMC != null && _targetMC.currentFrame == _prevFrame)					{						//trace("CORE: STOPPED");						stop();						if (_callback != null) _callback();					}				}						if (_notifyType & LOOP)				{					////trace("CORE: "+"[PlayHeadNotifier - loop] frame #: " + targetMC.currentFrame + " of " + targetMC.totalframes);					if (_targetMC != null && _targetMC.currentFrame < _prevFrame)					{						stop();						if (_callback != null) _callback();					}				}						if (_notifyType & EOF)				{					Debug.log(toString() + "Check for EOF - frame #" + _targetMC.currentFrame);					if (_targetMC != null && _targetMC.currentFrame >= _targetMC.totalFrames)					{						Debug.log(toString() + "EOF reached: " + _targetMC.currentFrame);						stop();												_prevFrame = 1;						////trace("CORE: "+"[PlayHeadNotifier - eof] end of frame " + targetMC);						_callback();							}								}								if (_targetMC != null)				{					_prevFrame = _targetMC.currentFrame;				}						} // end isRunning			else			{				trace("PlayHeadNotifier.checkFrame is still Running!!!");			}					}// end checkFrame		}//end class}// end package